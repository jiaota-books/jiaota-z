# 脚踏实地Z语言

## 介绍

《脚踏实地Z语言》这本书是我第一次尝试记录创造一个新事物的过程。

Z语言根源于C语言，它的设计目标是：

- 动静皆宜。即能兼容C，也能兼容Javascript。既静态编译、动态执行有机地结合起来；也能让静态类型和动态类型并行不悖。
- 面向场景编程。针对不同的场景，提供不同的语言特性（即功能子集）。Z既能当做C来开发嵌入式系统，也能当做Javascript来开发前端应用，还能当做Python来做科学计算。
- 能力梯度。基于前两个特性，Z能提供不同梯度的抽象能力、性能与安全。Z通过这种梯度来寻找“性能、易用性和安全”之间的平衡点。
- 组合与接口。接受C++、Java和D教训，Z尝试放弃基于继承的OOP，而是采用组合与接口来实现。

Z语言的具体设计和实现都放在[z-lang](https://gitee.com/z-lang/zc)这个工程中。

本书从汇编开始，一直到模板元编程，记录Z语言的设计与开发过程的点点滴滴，与其说是一本书，不如说是一本研发日志。

## 思路

上一节提到的任何一个特性都不是小事情。如果不是异想天开的话，我必须想出一条切实可行的实现路线来。

这才切合本书《脚踏实地》的精神。

所以，我打算把Z语言的开发分成4个阶段：

1. ZC。这个阶段的目标是做到与C看齐。即实现一个和C差不多能力的Z语言的子集。叫它ZC，既有C语言实现的意思，也有"Z Compiler"的意思。
1. ZZ。用ZC重写ZC编译器，实现自举。为了实现这一点，需要做到ZC和C的双向自动翻译。
1. ZJ。添加动态支持。前两个阶段都是纯粹的静态编译，这一阶段要实现动态执行。另外，还要添加动态类型的支持。以及与Javascript的双向翻译，打通Javascript生态。
1. Z。回归Z的本质，实现Z自身的类型系统、编译期执行、元编程等高阶特性。

这四个阶段也都不是轻而易举的事情。我也做了大致的规划。尤其第一阶段ZC，已经做好了资料查找和初步设计的准备。

### ZC

ZC的目标是做一个基本完整的过程式静态编译语言，除了语法上的一些差异，它和C基本一致。并且ABI层面和C兼容。

我把ZC的实现又分为了三个小目标：

1. 学习并模仿[ChibiCC](https://github.com/rui314/chibicc)，实现一个基本完整的ZC编译器。
2. 学习[LCC](https://drh.github.io/lcc/)，并融入它的一些优秀设计。
3. 学习[TCC](https://bellard.org/tcc/)，把它也融入进来。

这三个小目标完成之后，应该有一个足够完整的编译器框架了。

我最初选择的目标是TCC，但后来为什么先选择了ChibiCC和LCC呢？因为这俩编译器都有非常好的配套资料，上手相对容易些。

这其中ChibiCC采用了非常循序渐进的“增量式”开发模式，是学习C语言编译器的不二之选。另外，它也有本配套的书籍[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)，和代码同步，一步步介绍了设计和实现的细节。只可惜这本书还没有写完就暂停了，只介绍到第29步，后面的内容只能通过代码学习了。它的代码有足足几百步的增量更新过程，也基本做到了C11全覆盖，因此我相信自己能跟随它的脚步把第一版的ZC编译器做出来。

LCC相对较早一些。它对应的书籍是《A Retargetable C Compiler: Design and Implementation》，但除此之外，资料并不算太多。在完成初版ZC编译器之后，我会学习这本书和LCC的代码，看有没有什么地方可以借鉴。

TCC是一个设计非常精巧的编译器，是大神Fabrice Bellard的作品（虽然现在他早已不维护了）。我本来设计的目标就是修改TCC以支持ZC语法，因此完成前面两个里程碑之后，一定会读懂并借鉴TCC的实现。Bellard还有其他几个工程：QuickJS、QEMU、FFmpeg等，都是非常优秀的工程，未来我都会学习。尤其是QuickJS，会成为ZJ版本编译器的基础。

这三个目标实现的话，ZC就不再是一个“玩具语言”了。而是一个可以和C语言抗衡的静态编译语言。

ZC需要实现的Z语言特性子集包括：

ZC和C差不多的特性：

- 基本数据类型：整数、浮点数、布尔、字符串、指针。
- 函数：定义和调用，函数重载。
- 复合类型：数组、枚举。
- 自定义类型：type（类似于C的struct，但有所区别）。
- 变量：定义和使用。
- 语句：条件、循环、分支、返回。

ZC不支持的C特性有：

- 预处理器。我认为预处理的存在是汇编语言时代的遗留，现在设计新语言，应当把它的功能直接融入到语言本身。ZC的编写会尽量避免使用预处理器，实在无法避免的地方，需要在切换成ZZ之前用新的语言特性来替代。大概有这几个特性：常量（`#define`）、模块化（`#include`）、简单的条件编译（`#if`）、简单的模板元编程（代码生成宏）。这些功能需要在ZZ阶段实现。
- 指针运算。大部分的指针运算都可以用更慢的运算（如数组下标）来实现，因此在ZC阶段暂时不支持指针运算。等到最终的Z阶段，在设计嵌入式系统编程的时候，再考虑详细的`unsafe`特性。为此，ZC编译器的实现中不能使用指针运算。
- 联合体。暂时不打算支持联合体，因为这个特性感觉有点hack，本质上也不够安全。如果有必要，会在Z的`unsafe`特性中实现。ZC的编译器也尽量不使用联合体。虽然这样会降低性能。

ZC新增的特性：

- 模块化。不再需要头文件了，也不需要`include guard`了，也不需要`make`等工具来管理编译顺序依赖了。ZC编译器应当自己做好模块的引用和依赖工作。
- 方法。自定义的类型可以添加方法，并使用类似`D`的语法来调用。

有了这两条特性，ZC就可以实现基本的面向类编程（Class Based Programming，不是OOP）。

ZC完成的标志是实现自举，在这之前ZC的语法特性都有可能会根据自举开发的需求来修改。例如，可能需要联合体，或者需要支持简单的条件编译。

### ZZ

ZC到ZZ有两个阶段：

- 自举
- 扩展

第一个阶段要把C语言写的编译器改成用ZC来写，实现ZC编译ZC的自举。

1. 实现C到ZC的翻译。这需要我用ZC语言来重新写一个C语言的前端，将C翻译成ZC的AST即可。
1. 把ZC编译器的C语言代码翻译成ZC，并保证能编译通过。这个过程中需要反复尝试甚至修改ZC的特性，以做到能够支持C的编译器的功能。

ZZ的初版完成的标志就是实现ZC编译器的自举。从此以后Z相关的开发都可以脱离C语言本身了。

第二个阶段是添加更多的Z语言特性，让它成为一个超越C的语言。但这个阶段的设计目标不是成为一个完整的高阶语言，所以很多高阶特性，如完整的编译期执行，暂时不是我的目标。

初步设计的ZZ特性包括：

- 基本的条件编译和宏特性：替代C语言的预处理器。
- 较完善的面向对象设计：
    - 组合。扩展自定义类型的语法，支持类型组合。组合和方法结合起来，可以替代继承实现抽象概念的树状组织，而且和继承相比，组合模式没有运行时开销。
    - 接口。模仿Go语言的interface和Rust的trait，实现`Duck Typing`风格的接口。接口可以用来实现运行时多态。
- 完整的C互操作：
    - 动态加载C库：FFI。可能要考虑类似D的`extern`语法。
    - 静态编译的结果和C兼容：即可以作为.obj静态链接，也可以作为.so动态链接。
    - 源码级兼容：支持把Z翻译为C源码。以便于某些不方便使用Z编译器的环境可以直接使用Z的源码。
- 标准库：
    - 利用C翻译的功能，将很多C的标准库函数翻译成ZC的函数，以便在ZC中使用。
    - 某些不适合实现的库，可以先通过C的互操作特性来调用，并做一层封装。
    - io
    - net/http
    - data
      - json
      - redis
      - sqlite
    - 2d图形：可能考虑基于SDL2的封装。也可能参考cairo的设计。
    - ui：参考Nuklear或GTK
- 并发：
    - 协程：利用汇编实现最低开销的协程。支持类似`yield`的语法
    - 消息通讯：类似于Go语言的channel，但不阻塞。
    - async/await：更好的异步编程语法。
- 容器：
    - slice和iter：统一的容器访问接口。
    - map：语言层面有一个默认的实现，以方便未来扩充对JSON的支持。但编译器也要为第三方map库提供和系统map一样的语法糖支持，可以实现不同类型map的一键切换。
    - list
    - queue
    - stack
    - heap
    - tree
    - 所有容器均设计不可变版本，类似于clojure。
- 完整的工程管理
    - 包管理
    - builder
- 测试与调试：
    - 单元测试
    - 性能测试
    - 调试器

总之，作为一门较为完整的静态变易语言，ZZ应当和Go的特性看齐。

ZZ阶段的主要任务是完善语法和初步建立生态。

此时由于没有完整的编译期执行功能，无法实现高阶的类型推导、模板元编程和泛型，因此还无法建立完整的生态。这个阶段的生态目标是验证能够融入C生态的可行性。

### ZJ

ZJ是第三个阶段，实现完整的动态特性。这个阶段表面上看起来是为了打通Javascript或Python的生态，但实际上也是编译期执行等高阶特性的基础。

Z语言的高阶特性高度依赖于编译期的执行功能。而我打算实现的编译器执行功能的办法，是在Z编译器里塞进去一个解释器，在编译期可以调用解释器来执行任意Z代码，并通过模板或宏的方式与编译结果进行沟通。

所以ZJ首先需要实现一个解释器。而实现解释器了，那么就干脆把动态类型也加进来吧。

ZJ的设计分为4步：

1. 实现类似QuickJS的动态子集
2. 打通Javascript生态。
3. 实现ZZ的完整解释器。
4. 在编译期引入ZZ解释器，并实现一两个简单的高阶特性。

为什么用Javascript？因为Bellard的QuickJS我很感兴趣。而且Javascript毕竟比ZZ本身要简单，资料也非常丰富，实现Javascript的解释器难度远小于实现ZZ的解释器。
最后，JS生态对开发VSCode插件等周边工具也有很多好处。未来还可以考虑打通WASM生态，把Z语言做成半前端版语言。

那么Python呢？未来也考虑支持，不过由于先选了JS，作为ZJ之后就要立马转向ZZ的完整解释器，以至于编译期执行了。所以Python的支持要在第四阶段完整的Z语言定版后，再考虑添加。

打通Javascript生态，需要增加以下特性：

- 动态类型：`var`和`var fn`。
- JS Object：语言内置`[]`数组和`{}`映射。可以直接和JSON互转。
- 运行时反射。
- 标准库：添加Javascript相关的标准库，尤其是`DOM`操作相关的库。
- REPL和脚本执行模式。

ZZ作为静态语言，要实现完整的解释器并不容易。不过一旦做出来，会有很多好处：

- 可以实现完整的REPL，开启交互式开发模型。
- 可以简单地实现编译期执行，从而实现更多的Z高阶特性。
- 未来可以加入JIT，把动态解释、JIT、AOT三者结合起来，实现可热重载的编译服务器。

ZJ和ZC是两个不太相融的生态，因此这个阶段可以考虑实现初步的面向场景编程支持。这样用户就可以利用场景来分别用ZC子集和ZJ子集实现不同的应用了。

ZJ完善的标志是可以用Z语言同时实现Web前端和Server后端的开发，做出一个完整的Web应用框架。


### Z

有了编译期执行功能，Z终于可以完善所有的高阶特性了：

- 类型系统，sum type和product type，实现完整的编译期类型推导。借鉴TypeScript的设计。
- 泛型，借鉴D的设计。
- 模板元编程，利用清晰易懂的编译期执行机制，设计一套前所未有地简单的模板元编程语言。
- 代码生成和热重载。利用Z的动静结合机制，运行时生成新的静态可执行代码。

这些高阶特性实现之后，可以完善以下特性：

- 面向场景编程：不同的场景提供不同的语言子集。
- Unsafe：系统级编程的必要条件。做到和C一样强大，但更为安全。
- 内存管理：多梯度的内存管理机制。自动释放、垃圾回收、引用计数、手动管理等。配合面向场景编程，在不同场景中默认支持最合适的内存管理模式。用户可以自由配置。
- 跨平台：接入LLVM或WASM生态，并实现跨平台编译。

### ZIDE

Z完整版的标志是实现一套自洽的开发环境（ZIDE）：

- 源码编辑（需要底层的UI库、文本编辑器功能）
- 语法高亮与提示（需要完整的Language Server）
- 工程管理（需要完善的包管理和模块化，可能需要集中的仓库）
- 文档与互助（IDE集成文档系统、笔记系统和在线问答社区）
- 调试与测试（需要完整的调试器和测试框架）
- 跨平台和远程支持（需要实现Cross Compile和远程调试）
- WEB IDE
- AI辅助

ZIDE是Z语言开发的驱动器，类似于Servo浏览器和Rust的关系。

我开发Z语言，最初的目标也是自己做一个IDE出来。
因此可以看到Z语言的很多设计都是围绕着怎么实现这个IDE而努力的。
例如选择Javascript作为动态子集的参照物，也是以为我对IDE的最初设想是仿照VSCode的设计。

因此，在第一阶段ZC完成的时候，我就会同时开展ZIDE的设计与开发。
ZIDE的开发会伴随着Z语言的进化同时进行。


## 停止幻想，回到现实

Z语言的实现会是一个长期的过程，光写出上面这些规划就已经很累了。

所以我首先需要停止幻想，回到现实：我现在手上唯一的材料，就是ChibiCC。

先把最简版ZC这道小鲜烹调好吧。

长路漫漫，我将上下求索；前路崎岖，我得脚踏实地。
