## 起点

我站在起点。

这回不要眺望远方的山峰了。
周围什么都没有。

Z语言的世界，还是光秃秃一片，空无一物。

所有的一切，都需要我自己创造。

身边的工具，只有C语言。手头的地图，只有ChibiCC而已。

我需要做的，是尽量跟紧ChibiCC的每一步，稍作思考和修改，做出一个和C非常像的ZC编译器来。

等完成了这趟旅途，再回到起点，看看我创造了什么。大概是一棵小树苗吧。


## 前情回顾

在打算着手编写Z语言之前，我曾经尝试用Go来开发一门新语言，当时取的名字是**明语言**。

这个语言我只做了个开头，并没有具体实现。

它的设计还遗留在仓库中，可以一窥究竟：[明语言](https://gitee.com/ming-lang/ming/blob/master/docs/%E8%AE%BE%E8%AE%A1.md)。

可以看到，明语言有中英文两套语法设计。这个仓库的代码已经作废，最初是移植了凹语言的早期版本修改了部分，但没有完成。

后来它的中文语法加入到国产编程语言【[凹语言](https://wa-lang.org/)】，成为了凹语言的中文语法，简称“凹中文”。

凹语言是一门很有趣的语言，它的语法设计和我的明语言很像，但不同的是我还在设计阶段，它已经基本语法都实现了。
凹语言走了一条与众不同的道路，它的主力后端是WebAssembly，而不是传统的汇编或LLVM这样的中间框架。

凹语言的前端借鉴了Go语言的语法和早期实现，但很快就会实现自举（我估计在23年内）。
到时候凹语言会成为一个前后端打通的自主语言，再借助WASM的生态，它的应用场景会非常广泛。

那我为什么还会来写Z语言呢？最根本原因还是Go和C的区别。

我在设计明语言之前学习过《Writing A Interpreter In Go》和《Writing A Compiler In Go》这两本书，受益匪浅，从此正式踏上了编程语言的道路。
这两本书是我采用Go来开发编译器的初衷。

在凹语言之前，我还参考这两本书的实现做过一个简单版的明语言解释器，但后来没有能够超出“玩具语言”的范畴，最终放弃了。

随着学习的深入，尤其在凹团队的学习，让我更深地理解了Go的设计理念，以及它的局限性。

Go的设计理念是“Simple is better than complex”, "Slow is better than fast", "Clear is better than clever"。
Go的核心驱动场景是高并发网络服务，是大团队协同开发，所以它的一切设计都是围绕着这个场景来进行的。

这是Go的优势，也是它的局限。它使得Go更加适合大团队的高并发网络服务开发，但在面对其他场景时，它的某些优势反而会变成劣势。

举个例子：为了支持高并发，Go的运行时默认开启协程环境。换句话说，Go在运行`main`函数之前，就会启动整个并发运行环境。我们跑的`main`函数，实际上是跑在一个Goroutine中的。

这样会有什么问题呢？写一个最简单的HelloWorld，编译出来的代码也会提前运行一大堆东西，而他们并不都是必要的。

再比如，为了安全性和开发效率，Go默认采用垃圾回收，但垃圾回收是有开销的，且会有偶尔的卡顿，这就导致Go不能用在实时性要求较高的场景里。我认为这也是Go没有能在游戏行业或嵌入式行业获得长足发展的原因之一。

总得来说，Go被自己的优点限制了，它只能适应一种场景。

而C的理念是“自由”，是“底层”，是极致的性能。它让程序员自己去管理内存，自己去管理并发，自己去管理一切。
但是人无完人，什么都让程序员自己去管理，自然会带来一些问题。
所以C可以说是牺牲了安全性和开发效率，换来了极致的性能。

再加上C缺乏很多现代的语言特性，让它没法适应特普通公司的大团队项目开发（Linux这类精英团队除外）。所以C的发展也受到了不少限制。发展到现在，C只在底层和嵌入式领域有一席之地了。
应用层的开发被Java、Go、Python、JavaScript等语言所取代。而系统级的开发也被C++等继任者抢了不少市场。

但和Go不一样的地方是，C更加开放，你可以用它做任何事，包括修改它自己。而Go就不行了，Go最初是用C写的，但至今调用C的函数都不方便，甚至为了安全故意限制了调用C的效能。

我个人的场景需求既不符合Go，也不符合C：我想做个新语言，且为它开发一套完整的IDE。

编译器和IDE即接触了底层（可能需要编译成机器码，需要和操作系统打交道），也涉及到应用层（IDE主要的工作是GUI相关）。
虽然也有网络需求，但偏偏和Go所擅长的网络高并发服务场景并不一致。

Go至今也没有一套稳定的GUI库，语言本身也不适合做应用开发；而涉及底层，Go又不让人自由地调用C程序，这样很多底层库都没法好好用了。Go现在甚至都没有一套完善的动态加载功能。
所以我觉得Go不适合我这种场景。

C也不完全适应我的场景，但它至少是一个空白的开端，我可以随意修改，而不用担心它的限制。

所以我决定用C来开发Z语言，而不是Go。

或者说，我打算用C语言开发一个初始版的Z，之后的进一步修改都用Z自己来做了。


## 理想的编程语言

Z语言是我反复思考之后对“理想的编程语言”的一次设计尝试。

凹语言是一门很好的语言，但是它的编译目标是WASM，短期内做前端不如Javascript方便，做后端又不如Go方便，它的发展只能依赖于WASM生态的发展。

而我想做的语言是不依赖于任何生态的，即所谓的“跨生态”语言。
